### 排序算法
**本场最佳** ```sort(num, num + n)```
快速排序${\Large O}(N\log_{2}{N})$
```cpp
void quick_sort(int l, int  r)
{
    if(l == r) return ;
    int k = (num[l] + num[r]) >> 1, i = l - 1, j = r + 1;
    while(i < j){
        do i ++ ; while(num[i] < k);
        do j -- ; while(num[j] > k);
        if(i < j) swap(num[i], num[j]);
    }
    quick_sort(l, j); quick_sort(j + 1, r);
}
```
归并排序${\Large O}(N\log_{2}{N})$
```cpp
int num[M], tmp[M];
void merge_sort(int l, int r)
{
    if(l >= r)return;
    int mid = (l + r)>>1;
    merge_sort(l, mid), merge_sort(mid+1, r);
    int i = l, j = mid + 1, k = 0;
    while(i <= mid && j <= r){
        if(num[i] <= num[j]) tmp[k++] = num[i++];
        else    tmp[k++] = num[j++];
    }
    while(i <= mid) tmp[k++] = num[i++];
    while(j <= r)   tmp[k++] = num[j++];
    for(int x = l, y = 0; x <= r;) num[x++] = tmp[y++];
}
```
排序相关
求第K个数${\Large O}(N)$
```cpp
int kth_element(int l, int r, int k) // l , r是范围, k是所求第K个数
{
    if(l == r) return num[r];
    int mid = (num[l] + num[r]) >> 1, i = l - 1, j = r + 1;
    while(i < j){
        do i ++; while(num[i] < mid);
        do j --; while(num[j] > mid);
        if(i < j) swap(num[i], num[j]);
    }
    if(k <= j) return kth_element(l, j, k);
    return kth_element(j + 1, r, k);
}
```
与快排相比，求第K个数每次只需要递归一半，所以复杂度为${\Large O}(N)$；
STL中自带此函数：```nth_element(num, num + (k - 1), num + n);```
 // 起始位置， 第K个数， 末尾 + 1；

求逆序对${\Large O}(N\log_{2}{N})$
```cpp
int num[M], tmp[M], res;
void merge_sort(int l, int r)
{
    if(l >= r)return;
    int mid = (l + r)>>1;
    merge_sort(l, mid), merge_sort(mid+1, r);
    int i = l, j = mid + 1, k = 0;
    while(i <= mid && j <= r){
        if(num[i] <= num[j]) tmp[k++] = num[i++];
        else{
            tmp[k++] = num[j++];
            res += mid - i + 1; //res的值就是逆序数
        }
    }
    while(i <= mid) tmp[k++] = num[i++];
    while(j <= r)   tmp[k++] = num[j++];
    for(int x = l, y = 0; x <= r;) num[x++] = tmp[y++];
}
```
归并排序可用来求逆序对
原理：因为在合并过程中，当num[i] > num[j]，在前半部分中比num[i]大的都 > num[j]，将num[j] 放在 num[i]前面的话，逆序对需要加上 mid - i + 1;
相比较于树状数组求逆序对，归并排序不需要离散化。